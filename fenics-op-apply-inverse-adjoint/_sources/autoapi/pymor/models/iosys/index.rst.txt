:mod:`pymor.models.iosys`
=========================

.. py:module:: pymor.models.iosys


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   pymor.models.iosys.InputOutputModel
   pymor.models.iosys.InputStateOutputModel
   pymor.models.iosys.LTIModel
   pymor.models.iosys.TransferFunction
   pymor.models.iosys.SecondOrderModel
   pymor.models.iosys.LinearDelayModel
   pymor.models.iosys.LinearStochasticModel
   pymor.models.iosys.BilinearModel



Functions
~~~~~~~~~

.. autoapisummary::
  :nosignatures:

   pymor.models.iosys.sparse_min_size



.. function:: sparse_min_size(value=1000)

   Return minimal sparse problem size for which to warn about converting to dense.


.. class:: InputOutputModel(dim_input, dim_output, cont_time=True, error_estimator=None, visualizer=None, name=None)


   Bases: :py:obj:`pymor.models.interface.Model`

   Base class for input-output systems.

   .. attribute:: cache_region
      :annotation: = memory

      

   .. method:: eval_tf(self, s, mu=None)
      :abstractmethod:

      Evaluate the transfer function.


   .. method:: eval_dtf(self, s, mu=None)
      :abstractmethod:

      Evaluate the derivative of the transfer function.


   .. method:: freq_resp(self, w, mu=None)

      Evaluate the transfer function on the imaginary axis.

      .. admonition:: Parameters

          w
              A sequence of angular frequencies at which to compute the transfer function.
          mu
              |Parameter values| for which to evaluate the transfer function.
              
      .. admonition:: Returns

          tfw
              Transfer function values at frequencies in `w`, |NumPy array| of shape
              `(len(w), self.dim_output, self.dim_input)`.
              


   .. method:: bode(self, w, mu=None)

      Compute magnitudes and phases.

      .. admonition:: Parameters

          w
              A sequence of angular frequencies at which to compute the transfer function.
          mu
              |Parameter values| for which to evaluate the transfer function.
              
      .. admonition:: Returns

          mag
              Transfer function magnitudes at frequencies in `w`, |NumPy array| of shape
              `(len(w), self.dim_output, self.dim_input)`.
          phase
              Transfer function phases (in radians) at frequencies in `w`, |NumPy array| of shape
              `(len(w), self.dim_output, self.dim_input)`.
              


   .. method:: bode_plot(self, w, mu=None, ax=None, Hz=False, dB=False, deg=True, **mpl_kwargs)

      Draw the Bode plot for all input-output pairs.

      .. admonition:: Parameters

          w
              A sequence of angular frequencies at which to compute the transfer function.
          mu
              |Parameter| for which to evaluate the transfer function.
          ax
              Axis of shape (2 * `self.dim_output`, `self.dim_input`) to which to plot.
              If not given, `matplotlib.pyplot.gcf` is used to get the figure and create axis.
          Hz
              Should the frequency be in Hz on the plot.
          dB
              Should the magnitude be in dB on the plot.
          deg
              Should the phase be in degrees (otherwise in radians).
          mpl_kwargs
              Keyword arguments used in the matplotlib plot function.
              
      .. admonition:: Returns

          artists
              List of matplotlib artists added.
              


   .. method:: mag_plot(self, w, mu=None, ax=None, ord=None, Hz=False, dB=False, **mpl_kwargs)

      Draw the magnitude plot.

      .. admonition:: Parameters

          w
              A sequence of angular frequencies at which to compute the transfer function.
          mu
              |Parameter values| for which to evaluate the transfer function.
          ax
              Axis to which to plot.
              If not given, `matplotlib.pyplot.gca` is used.
          ord
              The order of the norm used to compute the magnitude (the default is the Frobenius norm).
          Hz
              Should the frequency be in Hz on the plot.
          dB
              Should the magnitude be in dB on the plot.
          mpl_kwargs
              Keyword arguments used in the matplotlib plot function.
              
      .. admonition:: Returns

          out
              List of matplotlib artists added.
              



.. class:: InputStateOutputModel(dim_input, solution_space, dim_output, cont_time=True, error_estimator=None, visualizer=None, name=None)


   Bases: :py:obj:`InputOutputModel`

   Base class for input-output systems with state space.

   .. method:: order(self)
      :property:



.. class:: LTIModel(A, B, C, D=None, E=None, cont_time=True, solver_options=None, error_estimator=None, visualizer=None, name=None)


   Bases: :py:obj:`InputStateOutputModel`

   Class for linear time-invariant systems.

   This class describes input-state-output systems given by

   .. math::
       E(\mu) \dot{x}(t, \mu) & = A(\mu) x(t, \mu) + B(\mu) u(t), \\
                    y(t, \mu) & = C(\mu) x(t, \mu) + D(\mu) u(t),

   if continuous-time, or

   .. math::
       E(\mu) x(k + 1, \mu) & = A(\mu) x(k, \mu) + B(\mu) u(k), \\
              y(k, \mu)     & = C(\mu) x(k, \mu) + D(\mu) u(k),

   if discrete-time, where :math:`A`, :math:`B`, :math:`C`, :math:`D`, and :math:`E` are linear
   operators.

   .. admonition:: Parameters

       A
           The |Operator| A.
       B
           The |Operator| B.
       C
           The |Operator| C.
       D
           The |Operator| D or `None` (then D is assumed to be zero).
       E
           The |Operator| E or `None` (then E is assumed to be identity).
       cont_time
           `True` if the system is continuous-time, otherwise `False`.
       solver_options
           The solver options to use to solve the Lyapunov equations.
       error_estimator
           An error estimator for the problem. This can be any object with an
           `estimate_error(U, mu, model)` method. If `error_estimator` is not `None`, an
           `estimate_error(U, mu)` method is added to the model which will call
           `error_estimator.estimate_error(U, mu, self)`.
       visualizer
           A visualizer for the problem. This can be any object with a
           `visualize(U, model, ...)` method. If `visualizer` is not `None`, a
           `visualize(U, *args, **kwargs)` method is added to the model which forwards its arguments to
           the visualizer's `visualize` method.
       name
           Name of the system.
           
   .. attribute:: order

      The order of the system.

   .. attribute:: dim_input

      The number of inputs.

   .. attribute:: dim_output

      The number of outputs.

   .. attribute:: A

      The |Operator| A.

   .. attribute:: B

      The |Operator| B.

   .. attribute:: C

      The |Operator| C.

   .. attribute:: D

      The |Operator| D.

   .. attribute:: E

      The |Operator| E.
      

   .. method:: __str__(self)

      Return str(self).


   .. method:: from_matrices(cls, A, B, C, D=None, E=None, cont_time=True, state_id='STATE', solver_options=None, error_estimator=None, visualizer=None, name=None)
      :classmethod:

      Create |LTIModel| from matrices.

      .. admonition:: Parameters

          A
              The |NumPy array| or |SciPy spmatrix| A.
          B
              The |NumPy array| or |SciPy spmatrix| B.
          C
              The |NumPy array| or |SciPy spmatrix| C.
          D
              The |NumPy array| or |SciPy spmatrix| D or `None` (then D is assumed to be zero).
          E
              The |NumPy array| or |SciPy spmatrix| E or `None` (then E is assumed to be identity).
          cont_time
              `True` if the system is continuous-time, otherwise `False`.
          state_id
              Id of the state space.
          solver_options
              The solver options to use to solve the Lyapunov equations.
          error_estimator
              An error estimator for the problem. This can be any object with an
              `estimate_error(U, mu, model)` method. If `error_estimator` is not `None`, an
              `estimate_error(U, mu)` method is added to the model which will call
              `error_estimator.estimate_error(U, mu, self)`.
          visualizer
              A visualizer for the problem. This can be any object with a `visualize(U, model, ...)`
              method. If `visualizer` is not `None`, a `visualize(U, *args, **kwargs)` method is added
              to the model which forwards its arguments to the visualizer's `visualize` method.
          name
              Name of the system.
              
      .. admonition:: Returns

          lti
              The |LTIModel| with operators A, B, C, D, and E.
              


   .. method:: from_files(cls, A_file, B_file, C_file, D_file=None, E_file=None, cont_time=True, state_id='STATE', solver_options=None, error_estimator=None, visualizer=None, name=None)
      :classmethod:

      Create |LTIModel| from matrices stored in separate files.

      .. admonition:: Parameters

          A_file
              The name of the file (with extension) containing A.
          B_file
              The name of the file (with extension) containing B.
          C_file
              The name of the file (with extension) containing C.
          D_file
              `None` or the name of the file (with extension) containing D.
          E_file
              `None` or the name of the file (with extension) containing E.
          cont_time
              `True` if the system is continuous-time, otherwise `False`.
          state_id
              Id of the state space.
          solver_options
              The solver options to use to solve the Lyapunov equations.
          error_estimator
              An error estimator for the problem. This can be any object with an
              `estimate_error(U, mu, model)` method. If `error_estimator` is not `None`, an
              `estimate_error(U, mu)` method is added to the model which will call
              `error_estimator.estimate_error(U, mu, self)`.
          visualizer
              A visualizer for the problem. This can be any object with a `visualize(U, model, ...)`
              method. If `visualizer` is not `None`, a `visualize(U, *args, **kwargs)` method is added
              to the model which forwards its arguments to the visualizer's `visualize` method.
          name
              Name of the system.
              
      .. admonition:: Returns

          lti
              The |LTIModel| with operators A, B, C, D, and E.
              


   .. method:: from_mat_file(cls, file_name, cont_time=True, state_id='STATE', solver_options=None, error_estimator=None, visualizer=None, name=None)
      :classmethod:

      Create |LTIModel| from matrices stored in a .mat file.

      .. admonition:: Parameters

          file_name
              The name of the .mat file (extension .mat does not need to be included) containing A, B,
              C, and optionally D and E.
          cont_time
              `True` if the system is continuous-time, otherwise `False`.
          state_id
              Id of the state space.
          solver_options
              The solver options to use to solve the Lyapunov equations.
          error_estimator
              An error estimator for the problem. This can be any object with an
              `estimate_error(U, mu, model)` method. If `error_estimator` is not `None`, an
              `estimate_error(U, mu)` method is added to the model which will call
              `error_estimator.estimate_error(U, mu, self)`.
          visualizer
              A visualizer for the problem. This can be any object with a `visualize(U, model, ...)`
              method. If `visualizer` is not `None`, a `visualize(U, *args, **kwargs)` method is added
              to the model which forwards its arguments to the visualizer's `visualize` method.
          name
              Name of the system.
              
      .. admonition:: Returns

          lti
              The |LTIModel| with operators A, B, C, D, and E.
              


   .. method:: from_abcde_files(cls, files_basename, cont_time=True, state_id='STATE', solver_options=None, error_estimator=None, visualizer=None, name=None)
      :classmethod:

      Create |LTIModel| from matrices stored in a .[ABCDE] files.

      .. admonition:: Parameters

          files_basename
              The basename of files containing A, B, C, and optionally D and E.
          cont_time
              `True` if the system is continuous-time, otherwise `False`.
          state_id
              Id of the state space.
          solver_options
              The solver options to use to solve the Lyapunov equations.
          error_estimator
              An error estimator for the problem. This can be any object with an
              `estimate_error(U, mu, model)` method. If `error_estimator` is not `None`, an
              `estimate_error(U, mu)` method is added to the model which will call
              `error_estimator.estimate_error(U, mu, self)`.
          visualizer
              A visualizer for the problem. This can be any object with a `visualize(U, model, ...)`
              method. If `visualizer` is not `None`, a `visualize(U, *args, **kwargs)` method is added
              to the model which forwards its arguments to the visualizer's `visualize` method.
          name
              Name of the system.
              
      .. admonition:: Returns

          lti
              The |LTIModel| with operators A, B, C, D, and E.
              


   .. method:: __add__(self, other)

      Add an |LTIModel|.


   .. method:: __sub__(self, other)

      Subtract an |LTIModel|.


   .. method:: __neg__(self)

      Negate the |LTIModel|.


   .. method:: __mul__(self, other)

      Postmultiply by an |LTIModel|.


   .. method:: poles(self, mu=None)

      Compute system poles.

      .. note::
          Assumes the systems is small enough to use a dense eigenvalue solver.

      .. admonition:: Parameters

          mu
              |Parameter values| for which to compute the systems poles.
              
      .. admonition:: Returns

          One-dimensional |NumPy array| of system poles.
              


   .. method:: eval_tf(self, s, mu=None)

      Evaluate the transfer function.

      The transfer function at :math:`s` is

      .. math::
          C(\mu) (s E(\mu) - A(\mu))^{-1} B(\mu) + D(\mu).

      .. note::
          Assumes that the number of inputs and outputs is much smaller than the order of the
          system.

      .. admonition:: Parameters

          s
              Complex number.
          mu
              |Parameter values|.
              
      .. admonition:: Returns

          tfs
              Transfer function evaluated at the complex number `s`, |NumPy array| of shape
              `(self.dim_output, self.dim_input)`.
              


   .. method:: eval_dtf(self, s, mu=None)

      Evaluate the derivative of the transfer function.

      The derivative of the transfer function at :math:`s` is

      .. math::
          -C(\mu) (s E(\mu) - A(\mu))^{-1} E(\mu)
              (s E(\mu) - A(\mu))^{-1} B(\mu).

      .. note::
          Assumes that the number of inputs and outputs is much smaller than the order of the
          system.

      .. admonition:: Parameters

          s
              Complex number.
          mu
              |Parameter values|.
              
      .. admonition:: Returns

          dtfs
              Derivative of transfer function evaluated at the complex number `s`, |NumPy array| of
              shape `(self.dim_output, self.dim_input)`.
              


   .. method:: gramian(self, typ, mu=None)

      Compute a Gramian.

      .. admonition:: Parameters

          typ
              The type of the Gramian:
              
              - `'c_lrcf'`: low-rank Cholesky factor of the controllability Gramian,
              - `'o_lrcf'`: low-rank Cholesky factor of the observability Gramian,
              - `'c_dense'`: dense controllability Gramian,
              - `'o_dense'`: dense observability Gramian.
              
              .. note::
                  For `'c_lrcf'` and `'o_lrcf'` types, the method assumes the system is asymptotically
                  stable.
                  For `'c_dense'` and `'o_dense'` types, the method assumes there are no two system
                  poles which add to zero.
          mu
              |Parameter values|.
              
      .. admonition:: Returns

          If typ is `'c_lrcf'` or `'o_lrcf'`, then the Gramian factor as a |VectorArray| from
          `self.A.source`.
          If typ is `'c_dense'` or `'o_dense'`, then the Gramian as a |NumPy array|.
              


   .. method:: _hsv_U_V(self, mu=None)

      Compute Hankel singular values and vectors.

      .. note::
          Assumes the system is asymptotically stable.

      .. admonition:: Parameters

          mu
              |Parameter values|.
              
      .. admonition:: Returns

          hsv
              One-dimensional |NumPy array| of singular values.
          Uh
              |NumPy array| of left singular vectors.
          Vh
              |NumPy array| of right singular vectors.
              


   .. method:: hsv(self, mu=None)

      Hankel singular values.

      .. note::
          Assumes the system is asymptotically stable.

      .. admonition:: Parameters

          mu
              |Parameter values|.
              
      .. admonition:: Returns

          sv
              One-dimensional |NumPy array| of singular values.
              


   .. method:: h2_norm(self, mu=None)

      Compute the H2-norm of the |LTIModel|.

      .. note::
          Assumes the system is asymptotically stable.

      .. admonition:: Parameters

          mu
              |Parameter values|.
              
      .. admonition:: Returns

          norm
              H_2-norm.
              


   .. method:: hinf_norm(self, mu=None, return_fpeak=False, ab13dd_equilibrate=False)

      Compute the H_infinity-norm of the |LTIModel|.

      .. note::
          Assumes the system is asymptotically stable.

      .. admonition:: Parameters

          mu
              |Parameter values|.
          return_fpeak
              Whether to return the frequency at which the maximum is achieved.
          ab13dd_equilibrate
              Whether `slycot.ab13dd` should use equilibration.
              
      .. admonition:: Returns

          norm
              H_infinity-norm.
          fpeak
              Frequency at which the maximum is achieved (if `return_fpeak` is `True`).
              


   .. method:: hankel_norm(self, mu=None)

      Compute the Hankel-norm of the |LTIModel|.

      .. note::
          Assumes the system is asymptotically stable.

      .. admonition:: Parameters

          mu
              |Parameter values|.
              
      .. admonition:: Returns

          norm
              Hankel-norm.
              



.. class:: TransferFunction(dim_input, dim_output, tf, dtf, parameters={}, cont_time=True, name=None)


   Bases: :py:obj:`InputOutputModel`

   Class for systems represented by a transfer function.

   This class describes input-output systems given by a transfer
   function :math:`H(s, mu)`.

   .. admonition:: Parameters

       dim_input
           The number of inputs.
       dim_output
           The number of outputs.
       tf
           The transfer function defined at least on the open right complex half-plane.
           `tf(s, mu)` is a |NumPy array| of shape `(p, m)`.
       dtf
           The complex derivative of `H` with respect to `s`.
       cont_time
           `True` if the system is continuous-time, otherwise `False`.
       name
           Name of the system.
           
   .. attribute:: dim_input

      The number of inputs.

   .. attribute:: dim_output

      The number of outputs.

   .. attribute:: tf

      The transfer function.

   .. attribute:: dtf

      The complex derivative of the transfer function.
      

   .. attribute:: __radd__
      

      

   .. method:: __str__(self)

      Return str(self).


   .. method:: eval_tf(self, s, mu=None)

      Evaluate the transfer function.


   .. method:: eval_dtf(self, s, mu=None)

      Evaluate the derivative of the transfer function.


   .. method:: __add__(self, other)


   .. method:: __sub__(self, other)


   .. method:: __rsub__(self, other)


   .. method:: __neg__(self)


   .. method:: __mul__(self, other)


   .. method:: __rmul__(self, other)


   .. method:: h2_norm(self, return_norm_only=True, **quad_kwargs)

      Compute the H2-norm using quadrature.

      This method uses `scipy.integrate.quad` and makes no assumptions on the form of the transfer
      function.

      By default, the absolute error tolerance in `scipy.integrate.quad` is set to zero (see its
      optional argument `epsabs`).
      It can be changed by using the `epsabs` keyword argument.

      .. admonition:: Parameters

          return_norm_only
              Whether to only return the approximate H2-norm.
          quad_kwargs
              Keyword arguments passed to `scipy.integrate.quad`.
              
      .. admonition:: Returns

          norm
              Computed H2-norm.
          norm_relerr
              Relative error estimate (returned if `return_norm_only` is `False`).
          info
              Quadrature info (returned if `return_norm_only` is `False` and `full_output` is `True`).
              See `scipy.integrate.quad` documentation for more details.
              



.. class:: SecondOrderModel(M, E, K, B, Cp, Cv=None, D=None, cont_time=True, solver_options=None, error_estimator=None, visualizer=None, name=None)


   Bases: :py:obj:`InputStateOutputModel`

   Class for linear second order systems.

   This class describes input-output systems given by

   .. math::
       M(\mu) \ddot{x}(t, \mu)
       + E(\mu) \dot{x}(t, \mu)
       + K(\mu) x(t, \mu)
       & =
           B(\mu) u(t), \\
       y(t, \mu)
       & =
           C_p(\mu) x(t, \mu)
           + C_v(\mu) \dot{x}(t, \mu)
           + D(\mu) u(t),

   if continuous-time, or

   .. math::
       M(\mu) x(k + 2, \mu)
       + E(\mu) x(k + 1, \mu)
       + K(\mu) x(k, \mu)
       & =
           B(\mu) u(k), \\
       y(k, \mu)
       & =
           C_p(\mu) x(k, \mu)
           + C_v(\mu) x(k + 1, \mu)
           + D(\mu) u(k),

   if discrete-time, where :math:`M`, :math:`E`, :math:`K`, :math:`B`, :math:`C_p`, :math:`C_v`,
   and :math:`D` are linear operators.

   .. admonition:: Parameters

       M
           The |Operator| M.
       E
           The |Operator| E.
       K
           The |Operator| K.
       B
           The |Operator| B.
       Cp
           The |Operator| Cp.
       Cv
           The |Operator| Cv or `None` (then Cv is assumed to be zero).
       D
           The |Operator| D or `None` (then D is assumed to be zero).
       cont_time
           `True` if the system is continuous-time, otherwise `False`.
       solver_options
           The solver options to use to solve the Lyapunov equations.
       error_estimator
           An error estimator for the problem. This can be any object with an
           `estimate_error(U, mu, model)` method. If `error_estimator` is not `None`, an
           `estimate_error(U, mu)` method is added to the model which will call
           `error_estimator.estimate_error(U, mu, self)`.
       visualizer
           A visualizer for the problem. This can be any object with a `visualize(U, model, ...)`
           method. If `visualizer` is not `None`, a `visualize(U, *args, **kwargs)` method is added to
           the model which forwards its arguments to the visualizer's `visualize` method.
       name
           Name of the system.
           
   .. attribute:: order

      The order of the system (equal to M.source.dim).

   .. attribute:: dim_input

      The number of inputs.

   .. attribute:: dim_output

      The number of outputs.

   .. attribute:: M

      The |Operator| M.

   .. attribute:: E

      The |Operator| E.

   .. attribute:: K

      The |Operator| K.

   .. attribute:: B

      The |Operator| B.

   .. attribute:: Cp

      The |Operator| Cp.

   .. attribute:: Cv

      The |Operator| Cv.

   .. attribute:: D

      The |Operator| D.
      

   .. method:: __str__(self)

      Return str(self).


   .. method:: from_matrices(cls, M, E, K, B, Cp, Cv=None, D=None, cont_time=True, state_id='STATE', solver_options=None, error_estimator=None, visualizer=None, name=None)
      :classmethod:

      Create a second order system from matrices.

      .. admonition:: Parameters

          M
              The |NumPy array| or |SciPy spmatrix| M.
          E
              The |NumPy array| or |SciPy spmatrix| E.
          K
              The |NumPy array| or |SciPy spmatrix| K.
          B
              The |NumPy array| or |SciPy spmatrix| B.
          Cp
              The |NumPy array| or |SciPy spmatrix| Cp.
          Cv
              The |NumPy array| or |SciPy spmatrix| Cv or `None` (then Cv is assumed to be zero).
          D
              The |NumPy array| or |SciPy spmatrix| D or `None` (then D is assumed to be zero).
          cont_time
              `True` if the system is continuous-time, otherwise `False`.
          solver_options
              The solver options to use to solve the Lyapunov equations.
          error_estimator
              An error estimator for the problem. This can be any object with an
              `estimate_error(U, mu, model)` method. If `error_estimator` is not `None`, an
              `estimate_error(U, mu)` method is added to the model which will call
              `error_estimator.estimate_error(U, mu, self)`.
          visualizer
              A visualizer for the problem. This can be any object with a `visualize(U, model, ...)`
              method. If `visualizer` is not `None`, a `visualize(U, *args, **kwargs)` method is added
              to the model which forwards its arguments to the visualizer's `visualize` method.
          name
              Name of the system.
              
      .. admonition:: Returns

          lti
              The SecondOrderModel with operators M, E, K, B, Cp, Cv, and D.
              


   .. method:: from_files(cls, M_file, E_file, K_file, B_file, Cp_file, Cv_file=None, D_file=None, cont_time=True, state_id='STATE', solver_options=None, error_estimator=None, visualizer=None, name=None)
      :classmethod:

      Create |LTIModel| from matrices stored in separate files.

      .. admonition:: Parameters

          M_file
              The name of the file (with extension) containing A.
          E_file
              The name of the file (with extension) containing E.
          K_file
              The name of the file (with extension) containing K.
          B_file
              The name of the file (with extension) containing B.
          Cp_file
              The name of the file (with extension) containing Cp.
          Cv_file
              `None` or the name of the file (with extension) containing Cv.
          D_file
              `None` or the name of the file (with extension) containing D.
          cont_time
              `True` if the system is continuous-time, otherwise `False`.
          state_id
              Id of the state space.
          solver_options
              The solver options to use to solve the Lyapunov equations.
          error_estimator
              An error estimator for the problem. This can be any object with an
              `estimate_error(U, mu, model)` method. If `error_estimator` is not `None`, an
              `estimate_error(U, mu)` method is added to the model which will call
              `error_estimator.estimate_error(U, mu, self)`.
          visualizer
              A visualizer for the problem. This can be any object with a `visualize(U, model, ...)`
              method. If `visualizer` is not `None`, a `visualize(U, *args, **kwargs)` method is added
              to the model which forwards its arguments to the visualizer's `visualize` method.
          name
              Name of the system.
              
      .. admonition:: Returns

          som
              The |SecondOrderModel| with operators M, E, K, B, Cp, Cv, and D.
              


   .. method:: to_lti(self)

      Return a first order representation.

      The first order representation

      .. math::
          \begin{bmatrix}
              I & 0 \\
              0 & M
          \end{bmatrix}
          \frac{\mathrm{d}}{\mathrm{d}t}\!
          \begin{bmatrix}
              x(t) \\
              \dot{x}(t)
          \end{bmatrix}
          & =
          \begin{bmatrix}
              0 & I \\
              -K & -E
          \end{bmatrix}
          \begin{bmatrix}
              x(t) \\
              \dot{x}(t)
          \end{bmatrix}
          +
          \begin{bmatrix}
              0 \\
              B
          \end{bmatrix}
          u(t), \\
          y(t)
          & =
          \begin{bmatrix}
              C_p & C_v
          \end{bmatrix}
          \begin{bmatrix}
              x(t) \\
              \dot{x}(t)
          \end{bmatrix}
          + D u(t)

      is returned.

      .. admonition:: Returns

          lti
              |LTIModel| equivalent to the second-order model.
              


   .. method:: __add__(self, other)

      Add a |SecondOrderModel| or an |LTIModel|.


   .. method:: __radd__(self, other)

      Add to an |LTIModel|.


   .. method:: __sub__(self, other)

      Subtract a |SecondOrderModel| or an |LTIModel|.


   .. method:: __rsub__(self, other)

      Subtract from an |LTIModel|.


   .. method:: __neg__(self)

      Negate the |SecondOrderModel|.


   .. method:: __mul__(self, other)

      Postmultiply by a |SecondOrderModel| or an |LTIModel|.


   .. method:: __rmul__(self, other)

      Premultiply by an |LTIModel|.


   .. method:: poles(self, mu=None)

      Compute system poles.

      .. note::
          Assumes the systems is small enough to use a dense eigenvalue solver.

      .. admonition:: Parameters

          mu
              |Parameter values|.
              
      .. admonition:: Returns

          One-dimensional |NumPy array| of system poles.
              


   .. method:: eval_tf(self, s, mu=None)

      Evaluate the transfer function.

      The transfer function at :math:`s` is

      .. math::
          (C_p(\mu) + s C_v(\mu))
              (s^2 M(\mu) + s E(\mu) + K(\mu))^{-1} B(\mu)
          + D(\mu).

      .. note::
          Assumes that the number of inputs and outputs is much smaller than the order of the
          system.

      .. admonition:: Parameters

          s
              Complex number.
          mu
              |Parameter values|.
              
      .. admonition:: Returns

          tfs
              Transfer function evaluated at the complex number `s`, |NumPy array| of shape
              `(self.dim_output, self.dim_input)`.
              


   .. method:: eval_dtf(self, s, mu=None)

      Evaluate the derivative of the transfer function.

      .. math::
          s C_v(\mu) (s^2 M(\mu) + s E(\mu) + K(\mu))^{-1} B(\mu)
          - (C_p(\mu) + s C_v(\mu))
              (s^2 M(\mu) + s E(\mu) + K(\mu))^{-1}
              (2 s M(\mu) + E(\mu))
              (s^2 M(\mu) + s E(\mu) + K(\mu))^{-1}
              B(\mu).

      .. note::
          Assumes that the number of inputs and outputs is much smaller than the order of the
          system.

      .. admonition:: Parameters

          s
              Complex number.
          mu
              |Parameter values|.
              
      .. admonition:: Returns

          dtfs
              Derivative of transfer function evaluated at the complex number `s`, |NumPy array| of
              shape `(self.dim_output, self.dim_input)`.
              


   .. method:: gramian(self, typ, mu=None)

      Compute a second-order Gramian.

      .. admonition:: Parameters

          typ
              The type of the Gramian:
              
              - `'pc_lrcf'`: low-rank Cholesky factor of the position controllability Gramian,
              - `'vc_lrcf'`: low-rank Cholesky factor of the velocity controllability Gramian,
              - `'po_lrcf'`: low-rank Cholesky factor of the position observability Gramian,
              - `'vo_lrcf'`: low-rank Cholesky factor of the velocity observability Gramian,
              - `'pc_dense'`: dense position controllability Gramian,
              - `'vc_dense'`: dense velocity controllability Gramian,
              - `'po_dense'`: dense position observability Gramian,
              - `'vo_dense'`: dense velocity observability Gramian.
              
              .. note::
                  For `'*_lrcf'` types, the method assumes the system is asymptotically stable.
                  For `'*_dense'` types, the method assumes there are no two system poles which add to
                  zero.
          mu
              |Parameter values|.
              
      .. admonition:: Returns

          If typ is `'pc_lrcf'`, `'vc_lrcf'`, `'po_lrcf'` or `'vo_lrcf'`, then the Gramian factor as a
          |VectorArray| from `self.M.source`.
          If typ is `'pc_dense'`, `'vc_dense'`, `'po_dense'` or `'vo_dense'`, then the Gramian as a
          |NumPy array|.
              


   .. method:: psv(self, mu=None)

      Position singular values.

      .. note::
          Assumes the system is asymptotically stable.

      .. admonition:: Parameters

          mu
              |Parameter values|.
              
      .. admonition:: Returns

          One-dimensional |NumPy array| of singular values.
              


   .. method:: vsv(self, mu=None)

      Velocity singular values.

      .. note::
          Assumes the system is asymptotically stable.

      .. admonition:: Parameters

          mu
              |Parameter values|.
              
      .. admonition:: Returns

          One-dimensional |NumPy array| of singular values.
              


   .. method:: pvsv(self, mu=None)

      Position-velocity singular values.

      .. note::
          Assumes the system is asymptotically stable.

      .. admonition:: Parameters

          mu
              |Parameter values|.
              
      .. admonition:: Returns

          One-dimensional |NumPy array| of singular values.
              


   .. method:: vpsv(self, mu=None)

      Velocity-position singular values.

      .. note::
          Assumes the system is asymptotically stable.

      .. admonition:: Parameters

          mu
              |Parameter values|.
              
      .. admonition:: Returns

          One-dimensional |NumPy array| of singular values.
              


   .. method:: h2_norm(self, mu=None)

      Compute the H2-norm.

      .. note::
          Assumes the system is asymptotically stable.

      .. admonition:: Parameters

          mu
              |Parameter values|.
              
      .. admonition:: Returns

          norm
              H_2-norm.
              


   .. method:: hinf_norm(self, mu=None, return_fpeak=False, ab13dd_equilibrate=False)

      Compute the H_infinity-norm.

      .. note::
          Assumes the system is asymptotically stable.

      .. admonition:: Parameters

          mu
              |Parameter values|.
          return_fpeak
              Should the frequency at which the maximum is achieved should be returned.
          ab13dd_equilibrate
              Should `slycot.ab13dd` use equilibration.
              
      .. admonition:: Returns

          norm
              H_infinity-norm.
          fpeak
              Frequency at which the maximum is achieved (if `return_fpeak` is `True`).
              


   .. method:: hankel_norm(self, mu=None)

      Compute the Hankel-norm.

      .. note::
          Assumes the system is asymptotically stable.

      .. admonition:: Parameters

          mu
              |Parameter values|.
              
      .. admonition:: Returns

          norm
              Hankel-norm.
              



.. class:: LinearDelayModel(A, Ad, tau, B, C, D=None, E=None, cont_time=True, error_estimator=None, visualizer=None, name=None)


   Bases: :py:obj:`InputStateOutputModel`

   Class for linear delay systems.

   This class describes input-state-output systems given by

   .. math::
       E x'(t)
       & =
           A x(t)
           + \sum_{i = 1}^q{A_i x(t - \tau_i)}
           + B u(t), \\
       y(t)
       & =
           C x(t)
           + D u(t),

   if continuous-time, or

   .. math::
       E x(k + 1)
       & =
           A x(k)
           + \sum_{i = 1}^q{A_i x(k - \tau_i)}
           + B u(k), \\
       y(k)
       & =
           C x(k)
           + D u(k),

   if discrete-time, where :math:`E`, :math:`A`, :math:`A_i`, :math:`B`, :math:`C`, and :math:`D`
   are linear operators.

   .. admonition:: Parameters

       A
           The |Operator| A.
       Ad
           The tuple of |Operators| A_i.
       tau
           The tuple of delay times (positive floats or ints).
       B
           The |Operator| B.
       C
           The |Operator| C.
       D
           The |Operator| D or `None` (then D is assumed to be zero).
       E
           The |Operator| E or `None` (then E is assumed to be identity).
       cont_time
           `True` if the system is continuous-time, otherwise `False`.
       error_estimator
           An error estimator for the problem. This can be any object with an
           `estimate_error(U, mu, model)` method. If `error_estimator` is not `None`, an
           `estimate_error(U, mu)` method is added to the model which will call
           `error_estimator.estimate_error(U, mu, self)`.
       visualizer
           A visualizer for the problem. This can be any object with a `visualize(U, model, ...)`
           method. If `visualizer` is not `None`, a `visualize(U, *args, **kwargs)` method is added to
           the model which forwards its arguments to the visualizer's `visualize` method.
       name
           Name of the system.
           
   .. attribute:: order

      The order of the system (equal to A.source.dim).

   .. attribute:: dim_input

      The number of inputs.

   .. attribute:: dim_output

      The number of outputs.

   .. attribute:: q

      The number of delay terms.

   .. attribute:: tau

      The tuple of delay times.

   .. attribute:: A

      The |Operator| A.

   .. attribute:: Ad

      The tuple of |Operators| A_i.

   .. attribute:: B

      The |Operator| B.

   .. attribute:: C

      The |Operator| C.

   .. attribute:: D

      The |Operator| D.

   .. attribute:: E

      The |Operator| E.
      

   .. method:: __str__(self)

      Return str(self).


   .. method:: __add__(self, other)

      Add an |LTIModel|, |SecondOrderModel| or |LinearDelayModel|.


   .. method:: __radd__(self, other)

      Add to an |LTIModel| or a |SecondOrderModel|.


   .. method:: __sub__(self, other)

      Subtract an |LTIModel|, |SecondOrderModel| or |LinearDelayModel|.


   .. method:: __rsub__(self, other)

      Subtract from an |LTIModel| or a |SecondOrderModel|.


   .. method:: __neg__(self)

      Negate the |LinearDelayModel|.


   .. method:: __mul__(self, other)

      Postmultiply by a |SecondOrderModel| or an |LTIModel|.


   .. method:: __rmul__(self, other)

      Premultiply by an |LTIModel| or a |SecondOrderModel|.


   .. method:: eval_tf(self, s, mu=None)

      Evaluate the transfer function.

      The transfer function at :math:`s` is

      .. math::
          C \left(s E - A
              - \sum_{i = 1}^q{e^{-\tau_i s} A_i}\right)^{-1} B
          + D.

      .. note::
          Assumes that the number of inputs and outputs is much smaller than the order of the
          system.

      .. admonition:: Parameters

          s
              Complex number.
          mu
              |Parameter values|.
              
      .. admonition:: Returns

          tfs
              Transfer function evaluated at the complex number `s`, |NumPy array| of shape
              `(self.dim_output, self.dim_input)`.
              


   .. method:: eval_dtf(self, s, mu=None)

      Evaluate the derivative of the transfer function.

      The derivative of the transfer function at :math:`s` is

      .. math::
          -C \left(s E - A
                  - \sum_{i = 1}^q{e^{-\tau_i s} A_i}\right)^{-1}
              \left(E
                  + \sum_{i = 1}^q{\tau_i e^{-\tau_i s} A_i}\right)
              \left(s E - A
                  - \sum_{i = 1}^q{e^{-\tau_i s} A_i}\right)^{-1} B.

      .. note::
          Assumes that the number of inputs and outputs is much smaller than the order of the
          system.

      .. admonition:: Parameters

          s
              Complex number.
          mu
              |Parameter values|.
              
      .. admonition:: Returns

          dtfs
              Derivative of transfer function evaluated at the complex number `s`, |NumPy array| of
              shape `(self.dim_output, self.dim_input)`.
              



.. class:: LinearStochasticModel(A, As, B, C, D=None, E=None, cont_time=True, error_estimator=None, visualizer=None, name=None)


   Bases: :py:obj:`InputStateOutputModel`

   Class for linear stochastic systems.

   This class describes input-state-output systems given by

   .. math::
       E \mathrm{d}x(t)
       & =
           A x(t) \mathrm{d}t
           + \sum_{i = 1}^q{A_i x(t) \mathrm{d}\omega_i(t)}
           + B u(t) \mathrm{d}t, \\
       y(t)
       & =
           C x(t)
           + D u(t),

   if continuous-time, or

   .. math::
       E x(k + 1)
       & =
           A x(k)
           + \sum_{i = 1}^q{A_i x(k) \omega_i(k)}
           + B u(k), \\
       y(k)
       & =
           C x(k)
           + D u(t),

   if discrete-time, where :math:`E`, :math:`A`, :math:`A_i`, :math:`B`, :math:`C`, and :math:`D`
   are linear operators and :math:`\omega_i` are stochastic processes.

   .. admonition:: Parameters

       A
           The |Operator| A.
       As
           The tuple of |Operators| A_i.
       B
           The |Operator| B.
       C
           The |Operator| C.
       D
           The |Operator| D or `None` (then D is assumed to be zero).
       E
           The |Operator| E or `None` (then E is assumed to be identity).
       cont_time
           `True` if the system is continuous-time, otherwise `False`.
       error_estimator
           An error estimator for the problem. This can be any object with an
           `estimate_error(U, mu, model)` method. If `error_estimator` is not `None`, an
           `estimate_error(U, mu)` method is added to the model which will call
           `error_estimator.estimate_error(U, mu, self)`.
       visualizer
           A visualizer for the problem. This can be any object with a `visualize(U, model, ...)`
           method. If `visualizer` is not `None`, a `visualize(U, *args, **kwargs)` method is added to
           the model which forwards its arguments to the visualizer's `visualize` method.
       name
           Name of the system.
           
   .. attribute:: order

      The order of the system (equal to A.source.dim).

   .. attribute:: dim_input

      The number of inputs.

   .. attribute:: dim_output

      The number of outputs.

   .. attribute:: q

      The number of stochastic processes.

   .. attribute:: A

      The |Operator| A.

   .. attribute:: As

      The tuple of |Operators| A_i.

   .. attribute:: B

      The |Operator| B.

   .. attribute:: C

      The |Operator| C.

   .. attribute:: D

      The |Operator| D.

   .. attribute:: E

      The |Operator| E.
      

   .. method:: __str__(self)

      Return str(self).



.. class:: BilinearModel(A, N, B, C, D, E=None, cont_time=True, error_estimator=None, visualizer=None, name=None)


   Bases: :py:obj:`InputStateOutputModel`

   Class for bilinear systems.

   This class describes input-output systems given by

   .. math::
       E x'(t)
       & =
           A x(t)
           + \sum_{i = 1}^m{N_i x(t) u_i(t)}
           + B u(t), \\
       y(t)
       & =
           C x(t)
           + D u(t),

   if continuous-time, or

   .. math::
       E x(k + 1)
       & =
           A x(k)
           + \sum_{i = 1}^m{N_i x(k) u_i(k)}
           + B u(k), \\
       y(k)
       & =
           C x(k)
           + D u(t),

   if discrete-time, where :math:`E`, :math:`A`, :math:`N_i`, :math:`B`, :math:`C`, and :math:`D`
   are linear operators and :math:`m` is the number of inputs.

   .. admonition:: Parameters

       A
           The |Operator| A.
       N
           The tuple of |Operators| N_i.
       B
           The |Operator| B.
       C
           The |Operator| C.
       D
           The |Operator| D or `None` (then D is assumed to be zero).
       E
           The |Operator| E or `None` (then E is assumed to be identity).
       cont_time
           `True` if the system is continuous-time, otherwise `False`.
       error_estimator
           An error estimator for the problem. This can be any object with an
           `estimate_error(U, mu, model)` method. If `error_estimator` is not `None`, an
           `estimate_error(U, mu)` method is added to the model which will call
           `error_estimator.estimate_error(U, mu, self)`.
       visualizer
           A visualizer for the problem. This can be any object with a `visualize(U, model, ...)`
           method. If `visualizer` is not `None`, a `visualize(U, *args, **kwargs)` method is added to
           the model which forwards its arguments to the visualizer's `visualize` method.
       name
           Name of the system.
           
   .. attribute:: order

      The order of the system (equal to A.source.dim).

   .. attribute:: dim_input

      The number of inputs.

   .. attribute:: dim_output

      The number of outputs.

   .. attribute:: A

      The |Operator| A.

   .. attribute:: N

      The tuple of |Operators| N_i.

   .. attribute:: B

      The |Operator| B.

   .. attribute:: C

      The |Operator| C.

   .. attribute:: D

      The |Operator| D.

   .. attribute:: E

      The |Operator| E.
      

   .. method:: __str__(self)

      Return str(self).



